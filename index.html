<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>doodle</title>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css?family=Pacifico" rel="stylesheet">
  </head>
  <body>
    <div id="preamble" class="preamble">
      <h1>
        <span>doodle</span>
        <button onclick="toggleSettings()">
          <svg height="24" width="24" viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></svg>
        </button>
        <button onclick="toggleWhat()">
          <svg height="24" width="24" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path></svg>
        </button>
      </h1>

      <div id="what" class="preamble-text" hidden>
        There's this thing called a Buddha board, which is a weird surface you paint on
        with water. As time passes, the water evaporates and your doodle
        dissapears. This is that, but on the web and with pixels.<br><br>
        Made with ðŸ‘¾ by <a href="https://twitter.com/notwaldorf">Monica</a>. ðŸ‘€
        this on <a href="https://github.com/notwaldorf/pixel-board">GitHub</a>.
      </div>
      <div id="settings" class="preamble-text" hidden>
        Press: <b>X</b> to reset the doodle, <b>C</b> to change the active colour.
        <div class="horizontal">
          <div class="slider-wrapper">
            <span class="slider-title">decay (<span id="decayDisplay" class="slider-value">10s</span>)</span>
            <input id="decay" type="range" min="1" max="30" step="1" value="10">
          </div>
          <div class="slider-wrapper">
            <span class="slider-title">size (<span id="pixelSizeDisplay" class="slider-value">16px</span>)</span>
            <input id="pixelSize" type="range" min="11" max="90" step="1" value="16">
          </div>
          <div class="slider-wrapper">
            <span class="slider-title">colour loop (<span id="cycleDisplay" class="slider-value">0s</span>)</span>
            <input id="cycle" type="range" min="0" max="5" step="0.1" value="0">
          </div>
        </div>
      </div>
    </div>

    <div id="colorsContainer"></div>
    <div id="container"></div>
  </body>

  <script>
    const STORAGE_KEY = '__âœ¨pixel_boardâœ¨__'
    const COLORS = [
      { name: 'black', hex: '#000000'},
      { name: 'red', hex: '#f44336'},
      { name: 'pink', hex: '#E91E63'},
      { name: 'purple', hex: '#9C27B0'},
      { name: 'deeppurple', hex: '#673AB7'},
      { name: 'indigo', hex: '#3F51B5'},
      { name: 'blue', hex: '#2196F3'},
      { name: 'lightblue', hex: '#03A9F4'},
      { name: 'cyan', hex: '#00BCD4'},
      { name: 'teal', hex: '#009688'},
      { name: 'green', hex: '#4CAF50'},
      { name: 'lightgreen', hex: '#8BC34A'},
      { name: 'lime', hex: '#CDDC39'},
      { name: 'yellow', hex: '#FFEB3B'},
      { name: 'amber', hex: '#FFC107'},
      { name: 'orange', hex: '#FF9800'},
      { name: 'deeporange', hex: '#FF5722'},
      { name: 'brown', hex: '#795548'},
      { name: 'grey', hex: '#9E9E9E'}
    ]
    var activeColor = 0;

    // Are there settings to load? Else put the defaults in.
    if (localStorage[STORAGE_KEY]) {
      var options = JSON.parse(localStorage.getItem(STORAGE_KEY));
      decay.value = options.decay;
      pixelSize.value = options.pixelSize;
      cycle.value = options.cycle;
      updateDecay();
      updatePixelSize();
      updateCycle();
    } else {
      updateLocalStorage();
    }

    window.onresize = function() {
      drawPreamble();
      redrawBoard();
    };
    window.onkeyup = dealWithKeyboardMash;
    decay.addEventListener('input', updateDecay);
    pixelSize.addEventListener('input', updatePixelSize);
    cycle.addEventListener('input', updateCycle);

    colorsContainer.addEventListener('click', function(event) {
      cycleColour(event.target.dataset.index);
    });

    // Ok, so. On mobile we simulate hover.
    container.addEventListener('touchmove', function(event) {
      var touch = event.touches[0];
      var target = document.elementFromPoint(touch.clientX, touch.clientY);

      // If the target actually changes, activate it and fade out the old one.
      // Otherwise, we're just hovering inside the same target.
      if (target !== window.__previousTarget) {
        if (window.__previousTarget)
          window.__previousTarget.classList.remove('active');
        target.classList.add('active');
        window.__previousTarget = target;
      }
    });

    drawPreamble();
    redrawBoard();

    function dealWithKeyboardMash(e) {
      var key = e.keyCode ? e.keyCode : e.which;
      if (key == 88) {  // x
        resetTraces();
      } else if (key == 67) {  // c
        cycleColour();
      } else if (key == 86) {  // v
        toggleSettings();
      }
    }

    function redrawBoard() {
      var size = parseInt(pixelSize.value);

      var offset =
          colorsContainer.getBoundingClientRect().top +
          colorsContainer.getBoundingClientRect().height;

       /* the 1px is for the border */
      var width = Math.floor((window.innerWidth) / (size + 1));
      var height = Math.floor((window.innerHeight - offset) / (size + 1));
      size = size + 'px';  // yuuuup.

      // Draw a grid of pixels.
      container.innerHTML = '';
      for (var i = 0; i < height; i++) {
        for (var j = 0; j < width; j++) {
          var box = document.createElement('div');
          box.tabindex = 1;
          box.className = 'box black';
          box.style.width = box.style.height = size;
          container.appendChild(box);
        }
        // Eh why not.
        container.appendChild(document.createElement('br'));
      }
      focusBoard();
    }

    // Lay out the "available colours" container.
    function drawPreamble() {
      var totalWidth = colorsContainer.getBoundingClientRect().width;
      var boxWidth = totalWidth / COLORS.length + 'px';

      colorsContainer.innerHTML = '';
      for (var i = 0; i < COLORS.length; i++) {
        var box = document.createElement('div');
        box.style.backgroundColor = COLORS[i].hex;
        box.style.width = box.style.height = boxWidth;
        box.dataset.index = i;
        box.tabindex = 1;
        if (i == 0) {
          box.className = 'active';
        }
        colorsContainer.appendChild(box);
      }
    }

    // Trigger a repaint to reset the animations.
    function resetTraces() {
      container.style.display = 'none';
      container.offsetHeight;
      container.style.display = 'block';
    }

    function cycleColour(value) {
      var all = container.querySelectorAll('.box');
      var colorBoxes = colorsContainer.querySelectorAll('div');
      var newOne = value || (parseInt(activeColor) + 1);

      // Highlight the next active colour.
      colorBoxes[activeColor].className = '';
      activeColor = (activeColor === COLORS.length - 1) ? 0 : newOne;
      colorBoxes[activeColor].className = 'active';

      // Apply it to all the pixels.
      for (var i = 0; i < all.length; i++) {
        all[i].className = 'box ' + COLORS[activeColor].name;
      }
    }

    function toggleSettings() {
      settings.hidden = !settings.hidden;
      redrawBoard();
    }

    function toggleWhat() {
      what.hidden = !what.hidden;
      redrawBoard();
    }

    function focusBoard() {
      container.focus();
    }

    function updateDecay() {
      decayDisplay.textContent = decay.value + 's';
      container.style.transitionDuration = decay.value + 's';
      focusBoard();
      updateLocalStorage();
    }

    function updatePixelSize() {
      redrawBoard();
      focusBoard();
      updateLocalStorage();
      pixelSizeDisplay.textContent = pixelSize.value + 'px';
    }

    function updateCycle() {
      updateLocalStorage();
      cycleDisplay.textContent = cycle.value + 's';
      if (cycle.value === 0) {
        stop();
      } else if (requestId == -1) {
        start();
      }
    }

    function updateLocalStorage() {
      var options = {
          'decay': decay.value,
          'pixelSize': pixelSize.value,
          'cycle': cycle.value
        };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(options));
    }

    var requestId = -1;
    var animationStartTime = 0;

    function animate() {
      setTimeout(function() {
        if (cycle.value == 0) {
          stop();
        } else {
          cycleColour();
          requestId = window.requestAnimationFrame(animate);
        }
      }, cycle.value * 1000);
    }
    function start() {
    	requestId = window.requestAnimationFrame(animate);
    }
    function stop() {
    	if (requestId !== 1)
    	  window.cancelAnimationFrame(requestId);
    	requestId = -1;
    }


  </script>

</html>
